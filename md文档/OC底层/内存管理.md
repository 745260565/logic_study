### 一、内存五大区

iOS中，常说的堆区、栈区都是指的虚拟内存，主要分以下五大区

1. 堆区：由程序员分配和释放，用于存放运行中被动态分配的内存段，大小不定，可以增加或缩减，由低到高，在iOS的ARC程序中，系统自动管理计数器，计数器为0的时候，当次runloop结束后，释放掉内存。堆中的地址通过指针访问，要访问堆中内存时，一般先需要通过栈区的指针地址，然后通过指针地址访问堆区，OC中使用`alloc`或者`new`开辟空间创建对象，C语言中使用`mallo、calloc、realloc`分配空间，`free`释放，一般0x6开头

2. 栈区：栈由编译器分配和释放，用于存方程序临时的变量，参数，局部变量等，是一块连续的内存区域，先进后出，由高向低，iOS主线栈大小是`1MB`，其它线程是`512KB`，一般0x7开头

3. 全局区（静态区）：全局区分为未初始化区：bss段和初始化全局区：data段，一般0x1开头

4. 常量区：存放`常量`,已初始化的全局变量，已初始化的静态变量，空间由系统管理，生命周期为整个程序运行期，一般0x1开头

5. 代码区：存放函数的二进制代码

   ![22688358-e33e465f0a223d8d](/Users/chenghao/Desktop/22688358-e33e465f0a223d8d.png)

### 二、iOS内存管理的方案

###### 2.1、nonopointerISA

`nonopointerISA: 0:纯isa指针，1:不止是类对象地址，isa包含类信息、对象的引用计数等`

查看alloc源码调试定位到initIsa

allocWithZone -> _objc_rootAllocWithZone -> _class_createInstanceFromZone -> initIsa

```c++
inline void 
objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)
{ 
  	isa_t newisa(0);
		*****
        newisa.extra_rc = 1;
    }
    isa = newisa;
}
```

注意到extra_rc，这里extra_rc就是对象的引用计数，说明苹果的优化是把引用计数存储到对象的isa中

**护展-isa_t详解**

查看ISA结构体位域

```c++
#			arm64 //对应iOS移动端
#     define ISA_MASK        0x0000000ffffffff8ULL
#     define ISA_MAGIC_MASK  0x000003f000000001ULL
#     define ISA_MAGIC_VALUE 0x000001a000000001ULL
#     define ISA_HAS_CXX_DTOR_BIT 1
#     define ISA_BITFIELD                                                     
        uintptr_t nonpointer        : 1;  //表示是否开启指针优化，0:纯isa指针 1:不止是类对象地址，isa包含了类信息、对象的引用计数等                                   
        uintptr_t has_assoc         : 1; // 关联对象标志位，0没有，1存在                                     
        uintptr_t has_cxx_dtor      : 1;  //该对象是否有C++或者Objc的析构器，如果有析构函数，则需有析构逻辑，如果没有，则可以更快的释放对旬
        uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ //存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。
        uintptr_t magic             : 6;  //用于调试器判断当前对象是真的对象还没有初始化空间                                     
        uintptr_t weakly_referenced : 1; //标志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。                           
        uintptr_t unused            : 1;//标志对象是否正在释放内存
        uintptr_t has_sidetable_rc  : 1;//当对象引用技术大于 10 时，则需要借用该变量存储进位
        uintptr_t extra_rc          : 19 //当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc
#     define RC_ONE   (1ULL<<45)
#     define RC_HALF  (1ULL<<18)
#   endif
# elif __x86_64__ //对应MacOS端
#   define ISA_MASK        0x00007ffffffffff8ULL
#   define ISA_MAGIC_MASK  0x001f800000000001ULL
#   define ISA_MAGIC_VALUE 0x001d800000000001ULL
#   define ISA_HAS_CXX_DTOR_BIT 1
#   define ISA_BITFIELD                                                        \
      uintptr_t nonpointer        : 1;                                         \
      uintptr_t has_assoc         : 1;                                         \
      uintptr_t has_cxx_dtor      : 1;                                         \
      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ //存储类指针的值。开启指针优化的情况下，在 x86 架构中有 44 位用来存储类指针。
      uintptr_t magic             : 6;                                         \
      uintptr_t weakly_referenced : 1;                                         \
      uintptr_t unused            : 1;                                         \
      uintptr_t has_sidetable_rc  : 1;                                         \
      uintptr_t extra_rc          : 8
#   define RC_ONE   (1ULL<<56)
#   define RC_HALF  (1ULL<<7)
```

<img src="/Users/chenghao/Desktop/2021061023093521.png" alt="2021061023093521" style="zoom:40%;" />

###### 2.2、tagged point

5S之后的一种优化，小对象类型 NSNumber  NSData  NSString，打上tagged标签后，`不再是地址，而是真正的值`

```objective-c
    NSString *firstString = @"helloworld";
    NSString *secondString = [NSString stringWithFormat:@"helloworld"];
    NSString *thirdString = @"hello";
    NSString *fourthString = [NSString stringWithFormat:@"hello"];
    
    NSLog(@"%p %@",firstString,[firstString class]);
    NSLog(@"%p %@",secondString,[secondString class]);
    NSLog(@"%p %@",thirdString,[thirdString class]);
    NSLog(@"%p %@",fourthString,[fourthString class]);
   
   打印输出
   	2022-07-27 16:12:41.065277+0800 OCTest[53504:3088675] 0x100a7c070 __NSCFConstantString
    2022-07-27 16:12:41.065357+0800 OCTest[53504:3088675] 0x282c556a0 __NSCFString
  	2022-07-27 16:12:41.065386+0800 OCTest[53504:3088675] 0x100a7c090 __NSCFConstantString
  	2022-07-27 16:12:41.065410+0800 OCTest[53504:3088675] 0xb3a7ee3798a9d5ec NSTaggedPointerString
```

NSCFConstantString：常量区

NSCFString：长字符串通过StringWithFormat创建时会出现，引用计数为1

NSTaggedPointerString：字符串长度小于9时自动生成

**tagged point**

tagged point：在总是为0的位置打上了标记的指针 -- 真正的值，与随机值混淆

inter最低位为1，arm最高位为1，即表示是tagged point，iOS13以后，最低的三位表示标签

**源码分析**

源码中搜索_objc_encodeTaggedPointer

```c++
static inline void * _Nonnull
_objc_encodeTaggedPointer(uintptr_t ptr)
{
    uintptr_t value = (objc_debug_taggedpointer_obfuscator ^ ptr);
#if OBJC_SPLIT_TAGGED_POINTERS
    if ((value & _OBJC_TAG_NO_OBFUSCATION_MASK) == _OBJC_TAG_NO_OBFUSCATION_MASK)
        return (void *)ptr;
    uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK;
    uintptr_t permutedTag = _objc_basicTagToObfuscatedTag(basicTag);
    value &= ~(_OBJC_TAG_INDEX_MASK << _OBJC_TAG_INDEX_SHIFT);
    value |= permutedTag << _OBJC_TAG_INDEX_SHIFT;
#endif
    return (void *)value;
}
```

可以看到，用objc_debug_taggedpointer_obfuscator和ptr异或运算混淆，搜索objc_debug_taggedpointer_obfuscator

```c++
/***********************************************************************
* initializeTaggedPointerObfuscator
* Initialize objc_debug_taggedpointer_obfuscator with randomness.
*
* The tagged pointer obfuscator is intended to make it more difficult
* for an attacker to construct a particular object as a tagged pointer,
* in the presence of a buffer overflow or other write control over some
* memory. The obfuscator is XORed with the tagged pointers when setting
* or retrieving payload values. They are filled with randomness on first
* use.
**********************************************************************/
static void
initializeTaggedPointerObfuscator(void)
```

其中initializeTaggedPointerObfuscator是在类的加载时调用，初始化一个随机值，用来混淆tagged point指针

那如何查看混淆前的值呢，查看源吗中有_objc_decodeTaggedPointer代码

```c++
static inline uintptr_t
_objc_decodeTaggedPointer(const void * _Nullable ptr)
{
    uintptr_t value = _objc_decodeTaggedPointer_noPermute(ptr);
#if OBJC_SPLIT_TAGGED_POINTERS
    uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK;

    value &= ~(_OBJC_TAG_INDEX_MASK << _OBJC_TAG_INDEX_SHIFT);
    value |= _objc_obfuscatedTagToBasicTag(basicTag) << _OBJC_TAG_INDEX_SHIFT;
#endif
    return value;
}
```

所以我们可以得到编解码的代码

```c++
#define lg_OBJC_TAG_INDEX_MASK 0x7UL
#define lg_OBJC_TAG_INDEX_SHIFT 0

extern uintptr_t objc_debug_taggedpointer_obfuscator;
extern uint8_t objc_debug_tag60_permutations[8];

uintptr_t lg_objc_obfuscatedTagToBasicTag(uintptr_t tag) {
    for (unsigned i = 0; i < 7; i++)
        if (objc_debug_tag60_permutations[i] == tag)
            return i;
    return 7;
}

//混淆解码
uintptr_t
lg_objc_decodeTaggedPointer(id ptr)
{
    uintptr_t value = (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;
    uintptr_t basicTag = (value >> lg_OBJC_TAG_INDEX_SHIFT) & lg_OBJC_TAG_INDEX_MASK;

    value &= ~(lg_OBJC_TAG_INDEX_MASK << lg_OBJC_TAG_INDEX_SHIFT);
    value |= lg_objc_obfuscatedTagToBasicTag(basicTag) << lg_OBJC_TAG_INDEX_SHIFT;
    return value;
}

static inline uintptr_t lg_objc_basicTagToObfuscatedTag(uintptr_t tag) {
    return objc_debug_tag60_permutations[tag];
}

//混淆编码
void *
lg_objc_encodeTaggedPointer(uintptr_t ptr)
{
    uintptr_t value = (objc_debug_taggedpointer_obfuscator ^ ptr);

    uintptr_t basicTag = (value >> lg_OBJC_TAG_INDEX_SHIFT) & lg_OBJC_TAG_INDEX_MASK;
    uintptr_t permutedTag = lg_objc_basicTagToObfuscatedTag(basicTag);
    value &= ~(lg_OBJC_TAG_INDEX_MASK << lg_OBJC_TAG_INDEX_SHIFT);
    value |= permutedTag << lg_OBJC_TAG_INDEX_SHIFT;
    return (void *)value;
}
```

还原并打印混淆前的地址

```objective-c
NSLog(@"0x%lx",lg_objc_decodeTaggedPointer(fourthString));
//打印输出
0x800037b63632b42a
```

查看0x800037b63632b42a二进制

```shell
(lldb) p/t 0x800037b63632b42a
(unsigned long) $0 = 0b1000000000000000001101111011011000110110001100101011010000101010
```

其中最高位为1表示是tagged Point，低三位010表示类型

源码搜索objc_tag

```c++
{
    // 60-bit payloads
    OBJC_TAG_NSAtom            = 0, 
    OBJC_TAG_1                 = 1, 
    OBJC_TAG_NSString          = 2, 
    OBJC_TAG_NSNumber          = 3, 
    OBJC_TAG_NSIndexPath       = 4, 
    OBJC_TAG_NSManagedObjectID = 5, 
    OBJC_TAG_NSDate            = 6,
		****
};
```

由此可得010为2，表示是NSString类型

1 - 表示

0000000000000000 - 空白

01101111 - 111 `o`

01101100 - 108 `l`

01101100 - 108 `l`

01100101 - 101 `e`

01101000 - 104 `h`

0101 - 表示长度，hello长度为5   

010 -  最低位表示是NSString

由些可见，tagged point是直接存储值

###### 2.3、sidetable

